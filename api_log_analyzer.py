#!/usr/bin/env python3
"""
API Log Analyzer for Paper Auditor

This script analyzes the API call logs generated by the Paper Auditor
to provide insights into API usage, performance, and error patterns.

Usage:
    python api_log_analyzer.py [--service SERVICE] [--errors-only] [--stats]
"""

import json
import argparse
import sys
from datetime import datetime
from collections import defaultdict, Counter
from pathlib import Path
from typing import Dict, List, Any


class APILogAnalyzer:
    """Analyze API call logs."""
    
    def __init__(self, log_file: str = "logs/api_calls.log"):
        """Initialize with log file path."""
        self.log_file = Path(log_file)
        self.logs = []
        self.load_logs()
    
    def load_logs(self):
        """Load and parse log entries."""
        if not self.log_file.exists():
            print(f"Log file {self.log_file} not found.")
            sys.exit(1)
        
        self.logs = []
        with open(self.log_file, 'r') as f:
            for line in f:
                if 'API_CALL:' in line:
                    try:
                        # Extract JSON part after 'API_CALL: '
                        json_part = line.split('API_CALL: ', 1)[1].strip()
                        log_entry = json.loads(json_part)
                        self.logs.append(log_entry)
                    except (json.JSONDecodeError, IndexError) as e:
                        print(f"Error parsing log line: {e}")
                        continue
        
        print(f"Loaded {len(self.logs)} API call entries.")
    
    def filter_logs(self, service: str = None, errors_only: bool = False) -> List[Dict]:
        """Filter logs based on criteria."""
        filtered = self.logs
        
        if service:
            filtered = [log for log in filtered if log.get('service') == service]
        
        if errors_only:
            filtered = [log for log in filtered if not log.get('success', False)]
        
        return filtered
    
    def generate_stats(self, service: str = None) -> Dict[str, Any]:
        """Generate comprehensive statistics."""
        logs = self.filter_logs(service=service)
        
        if not logs:
            return {'message': 'No logs found for the specified criteria.'}
        
        stats = {
            'total_calls': len(logs),
            'services': Counter(log['service'] for log in logs),
            'success_rate': sum(1 for log in logs if log.get('success', False)) / len(logs) * 100,
            'errors': Counter(log.get('error', 'Unknown') for log in logs if not log.get('success', False)),
            'response_times': {
                'by_service': defaultdict(list),
                'overall': []
            },
            'status_codes': Counter(log.get('response_status') for log in logs if log.get('response_status')),
            'methods': Counter(log['method'] for log in logs),
            'result_counts': {
                'by_service': defaultdict(list),
                'total_results': sum(log.get('result_count', 0) for log in logs)
            }
        }
        
        # Collect response times
        for log in logs:
            if log.get('response_time_ms'):
                stats['response_times']['overall'].append(log['response_time_ms'])
                stats['response_times']['by_service'][log['service']].append(log['response_time_ms'])
        
        # Collect result counts
        for log in logs:
            if log.get('result_count') is not None:
                stats['result_counts']['by_service'][log['service']].append(log['result_count'])
        
        # Calculate averages
        if stats['response_times']['overall']:
            stats['avg_response_time'] = sum(stats['response_times']['overall']) / len(stats['response_times']['overall'])
            stats['min_response_time'] = min(stats['response_times']['overall'])
            stats['max_response_time'] = max(stats['response_times']['overall'])
        
        return stats
    
    def print_stats(self, service: str = None):
        """Print formatted statistics."""
        stats = self.generate_stats(service=service)
        
        if 'message' in stats:
            print(stats['message'])
            return
        
        print("\n" + "="*60)
        title = f"API CALL STATISTICS"
        if service:
            title += f" - {service.upper()}"
        print(title.center(60))
        print("="*60)
        
        print(f"\nTotal API Calls: {stats['total_calls']}")
        print(f"Success Rate: {stats['success_rate']:.1f}%")
        
        if stats.get('avg_response_time'):
            print(f"Average Response Time: {stats['avg_response_time']:.2f} ms")
            print(f"Min Response Time: {stats['min_response_time']:.2f} ms")
            print(f"Max Response Time: {stats['max_response_time']:.2f} ms")
        
        print(f"\nTotal Results Retrieved: {stats['result_counts']['total_results']}")
        
        print(f"\nCalls by Service:")
        for service_name, count in stats['services'].most_common():
            print(f"  {service_name}: {count}")
        
        print(f"\nHTTP Methods:")
        for method, count in stats['methods'].most_common():
            print(f"  {method}: {count}")
        
        if stats['status_codes']:
            print(f"\nHTTP Status Codes:")
            for status, count in stats['status_codes'].most_common():
                print(f"  {status}: {count}")
        
        if stats['errors']:
            print(f"\nError Types:")
            for error, count in stats['errors'].most_common():
                print(f"  {error}: {count}")
        
        print(f"\nResponse Times by Service:")
        for service_name, times in stats['response_times']['by_service'].items():
            if times:
                avg_time = sum(times) / len(times)
                print(f"  {service_name}: {avg_time:.2f} ms avg ({len(times)} calls)")
    
    def print_recent_errors(self, count: int = 10):
        """Print recent error entries."""
        error_logs = [log for log in self.logs if not log.get('success', False)]
        recent_errors = sorted(error_logs, key=lambda x: x['timestamp'])[-count:]
        
        print(f"\n{'='*60}")
        print(f"RECENT ERRORS (Last {len(recent_errors)})".center(60))
        print('='*60)
        
        for log in recent_errors:
            timestamp = datetime.fromisoformat(log['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
            print(f"\n[{timestamp}] {log['service'].upper()}")
            print(f"URL: {log['url']}")
            if log.get('params'):
                print(f"Params: {log['params']}")
            print(f"Error: {log.get('error', 'Unknown error')}")
            if log.get('response_status'):
                print(f"Status: {log['response_status']}")
    
    def print_service_summary(self):
        """Print a summary for each service."""
        services = set(log['service'] for log in self.logs)
        
        print(f"\n{'='*60}")
        print("SERVICE SUMMARY".center(60))
        print('='*60)
        
        for service in sorted(services):
            service_logs = self.filter_logs(service=service)
            success_count = sum(1 for log in service_logs if log.get('success', False))
            total_count = len(service_logs)
            success_rate = (success_count / total_count * 100) if total_count > 0 else 0
            
            response_times = [log.get('response_time_ms') for log in service_logs if log.get('response_time_ms')]
            avg_time = sum(response_times) / len(response_times) if response_times else 0
            
            total_results = sum(log.get('result_count', 0) for log in service_logs)
            
            print(f"\n{service.upper()}:")
            print(f"  Total calls: {total_count}")
            print(f"  Success rate: {success_rate:.1f}%")
            print(f"  Average response time: {avg_time:.2f} ms")
            print(f"  Total results: {total_results}")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description='Analyze Paper Auditor API logs')
    parser.add_argument('--service', choices=['crossref', 'pubmed', 'arxiv'], 
                        help='Filter by specific service')
    parser.add_argument('--errors-only', action='store_true', 
                        help='Show only failed API calls')
    parser.add_argument('--stats', action='store_true', 
                        help='Show detailed statistics')
    parser.add_argument('--recent-errors', type=int, default=10, metavar='N',
                        help='Show N most recent errors (default: 10)')
    parser.add_argument('--log-file', default='logs/api_calls.log',
                        help='Path to log file (default: logs/api_calls.log)')
    
    args = parser.parse_args()
    
    analyzer = APILogAnalyzer(args.log_file)
    
    if not analyzer.logs:
        print("No API call logs found.")
        return
    
    if args.stats:
        analyzer.print_stats(service=args.service)
        analyzer.print_service_summary()
    elif args.errors_only:
        error_logs = analyzer.filter_logs(service=args.service, errors_only=True)
        if error_logs:
            print(f"Found {len(error_logs)} error entries:")
            for log in error_logs[-10:]:  # Show last 10 errors
                timestamp = datetime.fromisoformat(log['timestamp']).strftime('%Y-%m-%d %H:%M:%S')
                print(f"[{timestamp}] {log['service']}: {log.get('error', 'Unknown error')}")
        else:
            print("No errors found.")
    else:
        # Default: show recent errors and basic stats
        analyzer.print_recent_errors(args.recent_errors)
        analyzer.print_stats(service=args.service)


if __name__ == '__main__':
    main() 